% file for the first lab
%
% Assignment: create a Lamport Clock
% 
% details of the algorithm:
%   Three port objects interact with each other.
%
%   The basic algorithm is as follows:
%   Once a port object receives a message, it sends a message to each of the two
%   other port objects
%
%   Once that is done: add a sequence number/clock:
%   it is sent along with each message and it is incremented each time a process
%   sends one.
%   When a process receives a message with a clock higher than his, it updates
%   his clock to the received sequence number

% Gonna try first a single-node version
-module(lab1).
-compile(export_all).


start() ->
    N = 3, % number of agents
    Agents = [spawn(fun() -> agent(X) end) || X <- lists:seq(1,N) ],
    agent_full_mesh(Agents),
    list_send(setup_end, Agents),
    [A1|_] = Agents,
    A1 ! msg.

% send the message generated by Msg_gen to each of the Pids of the list
% Msg_gen must return {Msg, New_acc}
send_all([], _Msg_gen, _Acc) -> true;
send_all([Pid|T], Msg_gen, Acc) ->
    {Msg, New_acc} = Msg_gen(Acc),
    Pid ! Msg,
    send_all(T, Msg_gen, New_acc).

% Keep It Stupidly Simple  Msg_gen
kiss_msg_gen(Acc) -> {msg, Acc}.


% send a message to process list
list_send(_Msg, []) -> true;
list_send(Msg, [Pid|T]) -> Pid ! Msg, list_send(Msg, T).

% send list of messages to process
send_list_to(_Pid,[]) -> true;
send_list_to(Pid,[Msg|T]) -> Pid ! Msg, send_list_to(Pid, T).

% Connect all agents in full mesh by sending their Pids
agent_full_mesh([]) -> true;
agent_full_mesh([Pid|T]) ->
    send_list_to(Pid, T), 
        % send all remaining Pids of agents to the current agent
    list_send(Pid, T),
        % send the Pid of the current agent to the remaining ones
    agent_full_mesh(T).

% start agent 
agent(Name) -> agent_waiting_neightbours(Name, []).

% agent waits for neightbours. Neightbours should be a list of Pids.
agent_waiting_neightbours(Name, Neightbours) ->
    receive
        Pid when is_pid(Pid) -> 
            agent_waiting_neightbours(Name, [Pid | Neightbours]);
        setup_end -> 
            io:format("Agent ~p has ~p neightbours~n", 
                      [Name, length(Neightbours)]),
            agent_loop(Name, Neightbours);
        Any -> 
            io:format("Agent ~p stops on unknown message '~p' received while "
                      "waiting for neightbours~n" , [Name, Any])
    end.

% main agent loop: lamport clock
agent_loop(Name, Neightbours) ->
    receive
        msg -> 
            io:format("Agent ~p received a msg~n", [Name]),
            list_send(msg, Neightbours),
            agent_loop(Name, Neightbours);
        Any -> 
            io:format("Agent ~p stops on unknown message '~p'~n"
                        , [Name, Any])
    end.

